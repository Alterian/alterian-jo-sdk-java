/*
 * Journey Orchestration API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.30.49
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.jo.api;

import com.alterian.jo.ApiCallback;
import com.alterian.jo.ApiClient;
import com.alterian.jo.ApiException;
import com.alterian.jo.ApiResponse;
import com.alterian.jo.Configuration;
import com.alterian.jo.Pair;
import com.alterian.jo.ProgressRequestBody;
import com.alterian.jo.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.alterian.jo.model.Cluster;
import com.alterian.jo.model.ClusterResponse;
import com.alterian.jo.model.ClusterSetting;
import com.alterian.jo.model.ClusterStreamResponse;
import com.alterian.jo.model.ClusterThroughputResponse;
import com.alterian.jo.model.ModelApiResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClusterApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ClusterApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ClusterApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for clusterDecommissionDelete
     * @param targetnode Must match the private IP address of the node, so there is no ambiguity when decommissioning (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDecommissionDeleteCall(String targetnode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/decommission";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (targetnode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("targetnode", targetnode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterDecommissionDeleteValidateBeforeCall(String targetnode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'targetnode' is set
        if (targetnode == null) {
            throw new ApiException("Missing the required parameter 'targetnode' when calling clusterDecommissionDelete(Async)");
        }

        return clusterDecommissionDeleteCall(targetnode, _callback);

    }

    /**
     * Remove this node from the cluster
     * 
     * @param targetnode Must match the private IP address of the node, so there is no ambiguity when decommissioning (required)
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterDecommissionDelete(String targetnode) throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterDecommissionDeleteWithHttpInfo(targetnode);
        return localVarResp.getData();
    }

    /**
     * Remove this node from the cluster
     * 
     * @param targetnode Must match the private IP address of the node, so there is no ambiguity when decommissioning (required)
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterDecommissionDeleteWithHttpInfo(String targetnode) throws ApiException {
        okhttp3.Call localVarCall = clusterDecommissionDeleteValidateBeforeCall(targetnode, null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Remove this node from the cluster (asynchronously)
     * 
     * @param targetnode Must match the private IP address of the node, so there is no ambiguity when decommissioning (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDecommissionDeleteAsync(String targetnode, final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterDecommissionDeleteValidateBeforeCall(targetnode, _callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterDelete
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDeleteCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterDeleteValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return clusterDeleteCall(_callback);

    }

    /**
     * Removes from the cluster a down node that has not been seen for the longest
     * 
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterDelete() throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterDeleteWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Removes from the cluster a down node that has not been seen for the longest
     * 
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterDeleteWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = clusterDeleteValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Removes from the cluster a down node that has not been seen for the longest (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDeleteAsync(final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterDeleteValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterDiscoverPost
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDiscoverPostCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/discover";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterDiscoverPostValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return clusterDiscoverPostCall(_callback);

    }

    /**
     * Ask the cluster to rerun the discovery process.
     * 
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterDiscoverPost() throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterDiscoverPostWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Ask the cluster to rerun the discovery process.
     * 
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterDiscoverPostWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = clusterDiscoverPostValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Ask the cluster to rerun the discovery process. (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterDiscoverPostAsync(final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterDiscoverPostValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterFlushPost
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterFlushPostCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/flush";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterFlushPostValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return clusterFlushPostCall(_callback);

    }

    /**
     * Make sure all data in internal caches across the entire cluster are written to disk
     * 
     * @return ModelApiResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelApiResponse clusterFlushPost() throws ApiException {
        ApiResponse<ModelApiResponse> localVarResp = clusterFlushPostWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Make sure all data in internal caches across the entire cluster are written to disk
     * 
     * @return ApiResponse&lt;ModelApiResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelApiResponse> clusterFlushPostWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = clusterFlushPostValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Make sure all data in internal caches across the entire cluster are written to disk (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterFlushPostAsync(final ApiCallback<ModelApiResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterFlushPostValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterGet
     * @param update Also ping the other instances in the cluster to check that they are present. (optional)
     * @param repair Request an immediate repair so this instance will definitely contain the same rules, templates, etc   as the other instances in this cluster. Only works if all instances are up (optional)
     * @param includeSettings Include extended details (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterGetCall(Boolean update, Boolean repair, Boolean includeSettings, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (update != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("update", update));
        }

        if (repair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("repair", repair));
        }

        if (includeSettings != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeSettings", includeSettings));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterGetValidateBeforeCall(Boolean update, Boolean repair, Boolean includeSettings, final ApiCallback _callback) throws ApiException {
        return clusterGetCall(update, repair, includeSettings, _callback);

    }

    /**
     * Find out what instances are in the cluster
     * 
     * @param update Also ping the other instances in the cluster to check that they are present. (optional)
     * @param repair Request an immediate repair so this instance will definitely contain the same rules, templates, etc   as the other instances in this cluster. Only works if all instances are up (optional)
     * @param includeSettings Include extended details (optional)
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterGet(Boolean update, Boolean repair, Boolean includeSettings) throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterGetWithHttpInfo(update, repair, includeSettings);
        return localVarResp.getData();
    }

    /**
     * Find out what instances are in the cluster
     * 
     * @param update Also ping the other instances in the cluster to check that they are present. (optional)
     * @param repair Request an immediate repair so this instance will definitely contain the same rules, templates, etc   as the other instances in this cluster. Only works if all instances are up (optional)
     * @param includeSettings Include extended details (optional)
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterGetWithHttpInfo(Boolean update, Boolean repair, Boolean includeSettings) throws ApiException {
        okhttp3.Call localVarCall = clusterGetValidateBeforeCall(update, repair, includeSettings, null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find out what instances are in the cluster (asynchronously)
     * 
     * @param update Also ping the other instances in the cluster to check that they are present. (optional)
     * @param repair Request an immediate repair so this instance will definitely contain the same rules, templates, etc   as the other instances in this cluster. Only works if all instances are up (optional)
     * @param includeSettings Include extended details (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterGetAsync(Boolean update, Boolean repair, Boolean includeSettings, final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterGetValidateBeforeCall(update, repair, includeSettings, _callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterPost
     * @param cluster  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterPostCall(Cluster cluster, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cluster;

        // create path and map variables
        String localVarPath = "/cluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterPostValidateBeforeCall(Cluster cluster, final ApiCallback _callback) throws ApiException {
        return clusterPostCall(cluster, _callback);

    }

    /**
     * Register an instance with the cluster
     * 
     * @param cluster  (optional)
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterPost(Cluster cluster) throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterPostWithHttpInfo(cluster);
        return localVarResp.getData();
    }

    /**
     * Register an instance with the cluster
     * 
     * @param cluster  (optional)
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterPostWithHttpInfo(Cluster cluster) throws ApiException {
        okhttp3.Call localVarCall = clusterPostValidateBeforeCall(cluster, null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Register an instance with the cluster (asynchronously)
     * 
     * @param cluster  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterPostAsync(Cluster cluster, final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterPostValidateBeforeCall(cluster, _callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterPut
     * @param clusterSetting  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterPutCall(ClusterSetting clusterSetting, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = clusterSetting;

        // create path and map variables
        String localVarPath = "/cluster";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterPutValidateBeforeCall(ClusterSetting clusterSetting, final ApiCallback _callback) throws ApiException {
        return clusterPutCall(clusterSetting, _callback);

    }

    /**
     * Update an advanced cluster setting
     * 
     * @param clusterSetting  (optional)
     * @return ModelApiResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelApiResponse clusterPut(ClusterSetting clusterSetting) throws ApiException {
        ApiResponse<ModelApiResponse> localVarResp = clusterPutWithHttpInfo(clusterSetting);
        return localVarResp.getData();
    }

    /**
     * Update an advanced cluster setting
     * 
     * @param clusterSetting  (optional)
     * @return ApiResponse&lt;ModelApiResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelApiResponse> clusterPutWithHttpInfo(ClusterSetting clusterSetting) throws ApiException {
        okhttp3.Call localVarCall = clusterPutValidateBeforeCall(clusterSetting, null);
        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an advanced cluster setting (asynchronously)
     * 
     * @param clusterSetting  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterPutAsync(ClusterSetting clusterSetting, final ApiCallback<ModelApiResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterPutValidateBeforeCall(clusterSetting, _callback);
        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterReregisterPost
     * @param body Optional address of one seed node to register with. Same syntax as seed parameter in web.xml,   ipaddress:port (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterReregisterPostCall(String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/cluster/reregister";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/text"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterReregisterPostValidateBeforeCall(String body, final ApiCallback _callback) throws ApiException {
        return clusterReregisterPostCall(body, _callback);

    }

    /**
     * Make this note reregister itself with all the other nodes in the cluster without requiring a restart
     * 
     * @param body Optional address of one seed node to register with. Same syntax as seed parameter in web.xml,   ipaddress:port (optional)
     * @return ClusterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterResponse clusterReregisterPost(String body) throws ApiException {
        ApiResponse<ClusterResponse> localVarResp = clusterReregisterPostWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * Make this note reregister itself with all the other nodes in the cluster without requiring a restart
     * 
     * @param body Optional address of one seed node to register with. Same syntax as seed parameter in web.xml,   ipaddress:port (optional)
     * @return ApiResponse&lt;ClusterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterResponse> clusterReregisterPostWithHttpInfo(String body) throws ApiException {
        okhttp3.Call localVarCall = clusterReregisterPostValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Make this note reregister itself with all the other nodes in the cluster without requiring a restart (asynchronously)
     * 
     * @param body Optional address of one seed node to register with. Same syntax as seed parameter in web.xml,   ipaddress:port (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterReregisterPostAsync(String body, final ApiCallback<ClusterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterReregisterPostValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<ClusterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterStreamGet
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamGetCall(String targetnode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/stream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (targetnode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("targetnode", targetnode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterStreamGetValidateBeforeCall(String targetnode, final ApiCallback _callback) throws ApiException {
        return clusterStreamGetCall(targetnode, _callback);

    }

    /**
     * Find out the streaming status of an instance in the cluster
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ClusterStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterStreamResponse clusterStreamGet(String targetnode) throws ApiException {
        ApiResponse<ClusterStreamResponse> localVarResp = clusterStreamGetWithHttpInfo(targetnode);
        return localVarResp.getData();
    }

    /**
     * Find out the streaming status of an instance in the cluster
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ApiResponse&lt;ClusterStreamResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterStreamResponse> clusterStreamGetWithHttpInfo(String targetnode) throws ApiException {
        okhttp3.Call localVarCall = clusterStreamGetValidateBeforeCall(targetnode, null);
        Type localVarReturnType = new TypeToken<ClusterStreamResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find out the streaming status of an instance in the cluster (asynchronously)
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamGetAsync(String targetnode, final ApiCallback<ClusterStreamResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterStreamGetValidateBeforeCall(targetnode, _callback);
        Type localVarReturnType = new TypeToken<ClusterStreamResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterStreamThroughputGet
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamThroughputGetCall(String targetnode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/stream/throughput";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (targetnode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("targetnode", targetnode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterStreamThroughputGetValidateBeforeCall(String targetnode, final ApiCallback _callback) throws ApiException {
        return clusterStreamThroughputGetCall(targetnode, _callback);

    }

    /**
     * Find out the current stream throughput (Mb per sec) of an instance in the cluster
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ClusterThroughputResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterThroughputResponse clusterStreamThroughputGet(String targetnode) throws ApiException {
        ApiResponse<ClusterThroughputResponse> localVarResp = clusterStreamThroughputGetWithHttpInfo(targetnode);
        return localVarResp.getData();
    }

    /**
     * Find out the current stream throughput (Mb per sec) of an instance in the cluster
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ApiResponse&lt;ClusterThroughputResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterThroughputResponse> clusterStreamThroughputGetWithHttpInfo(String targetnode) throws ApiException {
        okhttp3.Call localVarCall = clusterStreamThroughputGetValidateBeforeCall(targetnode, null);
        Type localVarReturnType = new TypeToken<ClusterThroughputResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find out the current stream throughput (Mb per sec) of an instance in the cluster (asynchronously)
     * 
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamThroughputGetAsync(String targetnode, final ApiCallback<ClusterThroughputResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterStreamThroughputGetValidateBeforeCall(targetnode, _callback);
        Type localVarReturnType = new TypeToken<ClusterThroughputResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for clusterStreamThroughputPost
     * @param throughput The maximum data rate in Mb/s that this node can send across all streams. (required)
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamThroughputPostCall(Integer throughput, String targetnode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/cluster/stream/throughput";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (targetnode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("targetnode", targetnode));
        }

        if (throughput != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("throughput", throughput));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call clusterStreamThroughputPostValidateBeforeCall(Integer throughput, String targetnode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'throughput' is set
        if (throughput == null) {
            throw new ApiException("Missing the required parameter 'throughput' when calling clusterStreamThroughputPost(Async)");
        }

        return clusterStreamThroughputPostCall(throughput, targetnode, _callback);

    }

    /**
     * Set the current stream throughput (Mb per sec) of an instance in the cluster
     * 
     * @param throughput The maximum data rate in Mb/s that this node can send across all streams. (required)
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ClusterThroughputResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ClusterThroughputResponse clusterStreamThroughputPost(Integer throughput, String targetnode) throws ApiException {
        ApiResponse<ClusterThroughputResponse> localVarResp = clusterStreamThroughputPostWithHttpInfo(throughput, targetnode);
        return localVarResp.getData();
    }

    /**
     * Set the current stream throughput (Mb per sec) of an instance in the cluster
     * 
     * @param throughput The maximum data rate in Mb/s that this node can send across all streams. (required)
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @return ApiResponse&lt;ClusterThroughputResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClusterThroughputResponse> clusterStreamThroughputPostWithHttpInfo(Integer throughput, String targetnode) throws ApiException {
        okhttp3.Call localVarCall = clusterStreamThroughputPostValidateBeforeCall(throughput, targetnode, null);
        Type localVarReturnType = new TypeToken<ClusterThroughputResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Set the current stream throughput (Mb per sec) of an instance in the cluster (asynchronously)
     * 
     * @param throughput The maximum data rate in Mb/s that this node can send across all streams. (required)
     * @param targetnode Which instance (identified by host name) do you want to query? Leave blank to pick an instance   randomly (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call clusterStreamThroughputPostAsync(Integer throughput, String targetnode, final ApiCallback<ClusterThroughputResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = clusterStreamThroughputPostValidateBeforeCall(throughput, targetnode, _callback);
        Type localVarReturnType = new TypeToken<ClusterThroughputResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
